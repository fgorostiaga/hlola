
==================== FINAL INTERFACE ====================
2019-10-21 10:04:12.003902 UTC

interface HLola-0.1.0.0-81UMLq1MGfHEYLEYD1xjiJ:DecDyn 8065
  interface hash: fbef16109206ae8a4f94336035cc49cd
  ABI hash: e44279c7ab4d42b81c75c5ed2ac16b6e
  export-list hash: 040c7148a7a3f91e612a4e6a8a65bbcb
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 835ecb5d323c21c3e4cd3d34d4d606c2
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  DecDyn.dec2Dyn
  DecDyn.dec2Dyn'
  DecDyn.dgetId
  DecDyn.exp2Dyn
  DecDyn.fst4
  DecDyn.fth4
  DecDyn.getFromJSONers
  DecDyn.getReaders
  DecDyn.out
  DecDyn.snd4
  DecDyn.thd4
  DecDyn.DecDyn
  DecDyn.DecMap
  DecDyn.DeclarationDyn{DecDyn.DInp DecDyn.DOut}
  DecDyn.ExprDyn{DecDyn.DApp DecDyn.DAt DecDyn.DLeaf DecDyn.DNow}
  DecDyn.Format{DecDyn.CSV DecDyn.JSON}
  DecDyn.FromJSONers
  DecDyn.Readers
  DecDyn.Specification
module dependencies: Lola
package dependencies: aeson-1.4.5.0 array-0.5.3.0
                      attoparsec-0.13.2.3 base-4.12.0.0 base-compat-0.10.5
                      base-orphans-0.8.1 binary-0.8.6.0 bytestring-0.10.8.2
                      containers-0.6.0.1 deepseq-1.4.4.0 dlist-0.8.0.7 ghc-boot-th-8.6.5
                      ghc-prim-0.5.3 hashable-1.2.7.0 integer-gmp-1.0.2.0
                      integer-logarithms-1.0.3 primitive-0.6.4.0 random-1.1
                      scientific-0.3.6.2 tagged-0.8.6 template-haskell-2.14.0.0
                      text-1.2.3.1 time-1.8.0.2 time-compat-1.9.2.2 transformers-0.5.6.2
                      unordered-containers-0.2.10.0 uuid-types-1.0.3 vector-0.12.0.3
orphans: attoparsec-0.13.2.3:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.3:Data.Attoparsec.ByteString.Char8
         time-1.8.0.2:Data.Time.Clock.TAI
         vector-0.12.0.3:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show
         vector-0.12.0.3:Data.Vector.Fusion.Bundle
         transformers-0.5.6.2:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: aeson-1.4.5.0:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.3:Data.Attoparsec.Internal.Types
                         base-4.12.0.0:Control.Applicative base-4.12.0.0:Data.Complex
                         base-4.12.0.0:Data.Functor.Compose base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         dlist-0.8.0.7:Data.DList ghc-boot-th-8.6.5:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.5:GHC.LanguageExtensions.Type
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unordered-containers-0.2.10.0:Data.HashMap.Base
                         unordered-containers-0.2.10.0:Data.HashSet.Base
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.3:Data.Vector vector-0.12.0.3:Data.Vector.Primitive
                         vector-0.12.0.3:Data.Vector.Storable
                         vector-0.12.0.3:Data.Vector.Unboxed
                         vector-0.12.0.3:Data.Vector.Unboxed.Base
import  -/  Lola f52d080a9c6c535055cc2d321870899c
  exports: f0b2b11faceeef480fb3969a0b54aac2
  :@ 0e91454cfe22ab22364b2d071c8db005
  App 6313dab744ba77caf1d1e856525754b2
  Declaration b276a145c92628a19f5bf124ea374e0b
  Expr b276a145c92628a19f5bf124ea374e0b
  Ident e64c21a7ccd45786c76649982d91fabe
  Input 84bbb625cf5c7ec015044d911c3c39d7
  Leaf beb804f20541fc627fd77821a11a3d02
  Now 19aae6044cf44591930683cbda472505
  Output 7b0a74b3732a111075f4c4fb33e7b524
  Streamable 47494beae3139bbfdc210ceee05782ca
  getId ee2e8dc41a89be89599e6acd36d4e6cb
import  -/  aeson-1.4.5.0:Data.Aeson cd1e38ad278b969589c5b1ad8a30af94
import  -/  aeson-1.4.5.0:Data.Aeson.Types d55effe89210592b2e100cdb16229540
import  -/  aeson-1.4.5.0:Data.Aeson.Types.FromJSON 7d456473c8ab4a622bbb715c080f1c51
import  -/  aeson-1.4.5.0:Data.Aeson.Types.Internal caabc335ba2ec9f5ac75514abf283619
import  -/  aeson-1.4.5.0:Data.Aeson.Types.ToJSON 9a7d90dc49dd78eca820f5915fe6a168
import  -/  base-4.12.0.0:Data.Dynamic ef74395f5e02d1f1b1dbed7092c8bd30
import  -/  base-4.12.0.0:Data.Foldable efb37371da929e7bc88d896298d2d979
import  -/  base-4.12.0.0:Data.Maybe 9b76a39e833465c3c5b3c078b431417f
import  -/  base-4.12.0.0:Debug.Trace 60f75ad789dcddb29321db1cb21ccd4c
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:Text.Read 87f80fc2538a174aea915dd98f74fc0a
import  -/  containers-0.6.0.1:Data.Map.Internal 9e74e122af4fa0c1b8d4c844eeda9c98
import  -/  containers-0.6.0.1:Data.Map.Merge.Strict 4823e988e451066cf8402bebd448432f
import  -/  containers-0.6.0.1:Data.Map.Strict cdbeca9dfcd61c917272d3c2b8a5e4c8
import  -/  containers-0.6.0.1:Data.Map.Strict.Internal c59f919ec34c302d6b3008d3c43cbfe7
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
ecae1250810799f9368cb3bd439442ed
  $fEqFormat :: GHC.Classes.Eq DecDyn.Format
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ DecDyn.Format DecDyn.$fEqFormat_$c== DecDyn.$fEqFormat_$c/= -}
ecae1250810799f9368cb3bd439442ed
  $fEqFormat_$c/= :: DecDyn.Format -> DecDyn.Format -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: DecDyn.Format) (y :: DecDyn.Format) ->
                 case x of wild {
                   DecDyn.JSON
                   -> case y of wild1 {
                        DecDyn.JSON -> GHC.Types.False DecDyn.CSV -> GHC.Types.True }
                   DecDyn.CSV
                   -> case y of wild1 {
                        DecDyn.JSON -> GHC.Types.True DecDyn.CSV -> GHC.Types.False } }) -}
ecae1250810799f9368cb3bd439442ed
  $fEqFormat_$c== :: DecDyn.Format -> DecDyn.Format -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: DecDyn.Format) (ds1 :: DecDyn.Format) ->
                 case ds of wild {
                   DecDyn.JSON
                   -> case ds1 of wild1 {
                        DecDyn.JSON -> GHC.Types.True DecDyn.CSV -> GHC.Types.False }
                   DecDyn.CSV
                   -> case ds1 of wild1 {
                        DecDyn.JSON -> GHC.Types.False DecDyn.CSV -> GHC.Types.True } }) -}
1965aa6f1af02783601d880422aeb48a
  $fShowDeclarationDyn :: GHC.Show.Show DecDyn.DeclarationDyn
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ DecDyn.DeclarationDyn
                  DecDyn.$fShowDeclarationDyn_$cshowsPrec
                  DecDyn.$fShowDeclarationDyn_$cshow
                  DecDyn.$fShowDeclarationDyn_$cshowList -}
1965aa6f1af02783601d880422aeb48a
  $fShowDeclarationDyn1 ::
    DecDyn.DeclarationDyn -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: DecDyn.DeclarationDyn) (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (DecDyn.$fShowDeclarationDyn_$cshow x))
                   s) -}
2bf298ab50ce265d465992e00b59efe3
  $fShowDeclarationDyn2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (": "#) -}
a0cf47befdf465c300b01c20f7c0e5af
  $fShowDeclarationDyn3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Output "#) -}
1a5fefe7f39e6ba88bd1a862d2a874d8
  $fShowDeclarationDyn4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Input "#) -}
1965aa6f1af02783601d880422aeb48a
  $fShowDeclarationDyn_$cshow ::
    DecDyn.DeclarationDyn -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: DecDyn.DeclarationDyn) ->
                 case ds of wild {
                   DecDyn.DInp id
                   -> GHC.CString.unpackAppendCString#
                        DecDyn.$fShowDeclarationDyn4
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.$fShow(,)3
                           (GHC.Show.showLitString id GHC.Show.$fShow[]1))
                   DecDyn.DOut ds1
                   -> case ds1 of wild1 { (,) id exp ->
                      GHC.CString.unpackAppendCString#
                        DecDyn.$fShowDeclarationDyn3
                        (GHC.Base.++_$s++
                           @ GHC.Types.Char
                           (GHC.CString.unpackAppendCString#
                              DecDyn.$fShowDeclarationDyn2
                              (DecDyn.$fShowDeclarationDyn_$cshow1 exp))
                           GHC.Show.$fShow(,)3
                           (GHC.Show.showLitString id GHC.Show.$fShow[]1)) } }) -}
1965aa6f1af02783601d880422aeb48a
  $fShowDeclarationDyn_$cshow1 :: DecDyn.ExprDyn -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
1965aa6f1af02783601d880422aeb48a
  $fShowDeclarationDyn_$cshowList ::
    [DecDyn.DeclarationDyn] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [DecDyn.DeclarationDyn]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ DecDyn.DeclarationDyn
                   DecDyn.$fShowDeclarationDyn1
                   ls
                   s) -}
1965aa6f1af02783601d880422aeb48a
  $fShowDeclarationDyn_$cshowsPrec ::
    GHC.Types.Int -> DecDyn.DeclarationDyn -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: DecDyn.DeclarationDyn)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (DecDyn.$fShowDeclarationDyn_$cshow x))
                   s) -}
1965aa6f1af02783601d880422aeb48a
  $fShowExprDyn :: GHC.Show.Show DecDyn.ExprDyn
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ DecDyn.ExprDyn
                  DecDyn.$fShowExprDyn_$cshowsPrec
                  DecDyn.$fShowDeclarationDyn_$cshow1
                  DecDyn.$fShowExprDyn_$cshowList -}
1965aa6f1af02783601d880422aeb48a
  $fShowExprDyn1 ::
    DecDyn.ExprDyn -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: DecDyn.ExprDyn) (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (DecDyn.$fShowDeclarationDyn_$cshow1 x))
                   s) -}
1965aa6f1af02783601d880422aeb48a
  $fShowExprDyn_$cshowList :: [DecDyn.ExprDyn] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [DecDyn.ExprDyn]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ DecDyn.ExprDyn DecDyn.$fShowExprDyn1 ls s) -}
1965aa6f1af02783601d880422aeb48a
  $fShowExprDyn_$cshowsPrec ::
    GHC.Types.Int -> DecDyn.ExprDyn -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: DecDyn.ExprDyn)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (DecDyn.$fShowDeclarationDyn_$cshow1 x))
                   s) -}
4b4801a9ba3028f4a04940e2f7043dc5
  $sfind1 :: Lola.Ident -> Data.Map.Internal.Map Lola.Ident a -> a
  {- Arity: 2, Strictness: <S,U><S,1*U> -}
0a10ef9d2d7c871b5b90de41a3c10329
  $sinsert_$sgo8 ::
    Lola.Ident
    -> a1
    -> Data.Map.Internal.Map Lola.Ident a1
    -> Data.Map.Internal.Map Lola.Ident a1
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
cfe53c5c7353ee4751ec6d5ee5e85f33
  $smember1 ::
    Lola.Ident -> Data.Map.Internal.Map Lola.Ident a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
3a48068919745a4ae9e83bf3963d453b
  $tc'CSV :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8621605566126704519##
                   13754873861368555404##
                   DecDyn.$trModule
                   DecDyn.$tc'CSV2
                   0#
                   DecDyn.$tc'CSV1) -}
31f3384363aba0d02cb0bece2a10f900
  $tc'CSV1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
ad8829d1d5c2cffd597d2aac632fc9e3
  $tc'CSV2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tc'CSV3) -}
14e1ebc4ba2aadc03b39c93f9b35f643
  $tc'CSV3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'CSV"#) -}
bcb4157980e363216a6874fbefd5b97f
  $tc'DApp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3271012787544388310##
                   8659848546493741658##
                   DecDyn.$trModule
                   DecDyn.$tc'DApp2
                   0#
                   DecDyn.$tc'DApp1) -}
bd66ab199e384de46e18e878a8379c93
  $tc'DApp1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
305df6c41cd760e0e2754e13b66e0228
  $tc'DApp2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tc'DApp3) -}
6eaf97580e49fcbca97d19fe5b7daac2
  $tc'DApp3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DApp"#) -}
efb0f11d654cf64f19fcd3e5145d8c8b
  $tc'DAt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9736829315626319833##
                   9446522209092251422##
                   DecDyn.$trModule
                   DecDyn.$tc'DAt2
                   0#
                   DecDyn.$tc'DAt1) -}
46ba9a9bba0c319231e1a901135025e4
  $tc'DAt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
81ca5edec515c4312b477c83b499764e
  $tc'DAt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tc'DAt3) -}
285a93e2ff7a3eead70572d257dccd8a
  $tc'DAt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DAt"#) -}
c6ec1d3905538e260ba256c5b74b9a22
  $tc'DInp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2632245108921348548##
                   7812697550105257140##
                   DecDyn.$trModule
                   DecDyn.$tc'DInp2
                   0#
                   DecDyn.$tc'DInp1) -}
566c8070529ae1c3b89e9bb42eb25338
  $tc'DInp1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1e13451e2d658bd01efaa305e719a526
  $tc'DInp2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tc'DInp3) -}
2256025cad1c335b26263a292c3efa24
  $tc'DInp3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DInp"#) -}
4c587fb65a251c9881e201f4f3be0a83
  $tc'DLeaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4448930689093978298##
                   509289857383176385##
                   DecDyn.$trModule
                   DecDyn.$tc'DLeaf2
                   0#
                   DecDyn.$tc'DLeaf1) -}
9d1f90e33ff0fedc90450828c5739b61
  $tc'DLeaf1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
df5cc1114e4c3a28288800fdf3762ef0
  $tc'DLeaf2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tc'DLeaf3) -}
f91418d5486ecabf105e671ddd647c01
  $tc'DLeaf3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DLeaf"#) -}
ef7685fa8ca13f9fcbf46b2369d6b681
  $tc'DNow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15223823173547708914##
                   1041886667760375833##
                   DecDyn.$trModule
                   DecDyn.$tc'DNow2
                   0#
                   DecDyn.$tc'DNow1) -}
ed8d93f7731372f31f76fdf8412595fe
  $tc'DNow1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
57480aa1bf25fb13ba32d5d70bbda9fe
  $tc'DNow2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tc'DNow3) -}
196200a9b39ea6fe107216db5426a470
  $tc'DNow3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DNow"#) -}
30377cc9ac572a6de35b4323c7f24608
  $tc'DOut :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13877397906547918468##
                   2530154621547625081##
                   DecDyn.$trModule
                   DecDyn.$tc'DOut2
                   0#
                   DecDyn.$tc'DOut1) -}
1598f0d3e1765b4608c3b91bb8f575fe
  $tc'DOut1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
514398a08f59ea0eda0391ecad989014
  $tc'DOut2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tc'DOut3) -}
336002ffd33adbdd421603f0eb01c1ba
  $tc'DOut3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DOut"#) -}
9ec8d77ee065093bb776b614009f2a12
  $tc'JSON :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4040996946317944689##
                   10376301310348440020##
                   DecDyn.$trModule
                   DecDyn.$tc'JSON1
                   0#
                   DecDyn.$tc'CSV1) -}
a916162e0d7297ea254d95949c9562ac
  $tc'JSON1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tc'JSON2) -}
5938eecbf9437ba14d69ca663737f7e5
  $tc'JSON2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'JSON"#) -}
c0818c0933f4fa7a0af69794169844e5
  $tcDeclarationDyn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5860163855295381109##
                   16318917857504890092##
                   DecDyn.$trModule
                   DecDyn.$tcDeclarationDyn1
                   0#
                   GHC.Types.krep$*) -}
7e6229d0156375e8d3435f65809389bf
  $tcDeclarationDyn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tcDeclarationDyn2) -}
0d67071f24c7c3e8f00b0daf08bc7a58
  $tcDeclarationDyn2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DeclarationDyn"#) -}
ac663c5676d3fffded438ba40d0f7581
  $tcExprDyn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9693416113686298441##
                   14055472849184533004##
                   DecDyn.$trModule
                   DecDyn.$tcExprDyn1
                   0#
                   GHC.Types.krep$*) -}
4874829ac28ea69c4e6cba18fa129be7
  $tcExprDyn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tcExprDyn2) -}
21a1ec9bfa280949691615b62c83b2b9
  $tcExprDyn2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ExprDyn"#) -}
b8d0f524b591f3e3d23e9e0fbb1d152b
  $tcFormat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12691237150329440913##
                   6800521275182772365##
                   DecDyn.$trModule
                   DecDyn.$tcFormat1
                   0#
                   GHC.Types.krep$*) -}
08d03947b520ddd63b0ec165b813ede6
  $tcFormat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$tcFormat2) -}
2a3915cf0a023bf3a35998e455dcd856
  $tcFormat2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Format"#) -}
7a07e204c30c10e5241c6342bee25d72
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   DecDyn.$trModule3
                   DecDyn.$trModule1) -}
09ca3ec69d9685f7fe6d91e1dbe1a890
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$trModule2) -}
0197540386716414c5bc21577e744689
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DecDyn"#) -}
3fd914d11cd08c408aef36b39e28704b
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS DecDyn.$trModule4) -}
cad38e59d7c84f997b5ac78b5982b3c6
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("HLola-0.1.0.0-81UMLq1MGfHEYLEYD1xjiJ"#) -}
55fef9c37340cf3bb88d2b2b4654822b
  $w$sgo13 ::
    Lola.Ident
    -> Data.Map.Internal.Map Lola.Ident a1
    -> (# Data.Map.Internal.Map Lola.Ident a1, GHC.Maybe.Maybe a1,
          Data.Map.Internal.Map Lola.Ident a1 #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [2] -}
4b9f1f267e97861063e0e8677b761f7e
  $wdec2Dyn ::
    (Lola.Streamable a, GHC.Show.Show a,
     Data.Aeson.Types.ToJSON.ToJSON a) =>
    Lola.Declaration a
    -> (# DecDyn.DeclarationDyn,
          (Data.Dynamic.Dynamic -> GHC.Base.String,
           Data.Dynamic.Dynamic -> Data.Aeson.Types.Internal.Value),
          DecDyn.Readers, DecDyn.FromJSONers #)
  {- Arity: 4,
     Strictness: <L,U><L,U(A,C(U),A)><L,U(C(U),A,A,A)><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ a
                   (w :: Lola.Streamable a)
                   (w1 :: GHC.Show.Show a)
                   (w2 :: Data.Aeson.Types.ToJSON.ToJSON a)
                   (w3 :: Lola.Declaration a) ->
                 let {
                   ds :: (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers)
                   = case w3 of wild {
                       Lola.Input $dFromJSON $dRead $dTypeable x
                       -> DecDyn.$sfind1
                            @ (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers)
                            x
                            (DecDyn.dec2Dyn'
                               @ a
                               (Data.Map.Internal.Tip
                                  @ Lola.Ident
                                  @ (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers))
                               wild)
                       Lola.Output $dTypeable ds1
                       -> case ds1 of wild1 { (,) x ds2 ->
                          DecDyn.$sfind1
                            @ (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers)
                            x
                            (DecDyn.dec2Dyn'
                               @ a
                               (Data.Map.Internal.Tip
                                  @ Lola.Ident
                                  @ (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers))
                               wild) } }
                 } in
                 (# case ds of wild { (,,) ed thereaders thejsoners -> ed },
                    (\ (x :: Data.Dynamic.Dynamic) ->
                     GHC.Show.show
                       @ a
                       w1
                       (case x of wild { Data.Dynamic.Dynamic a1 t v ->
                        case Data.Typeable.Internal.sameTypeRep
                               @ *
                               @ *
                               @ a1
                               @ a
                               t
                               w `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild1 {
                          GHC.Types.False -> Data.Maybe.fromJust1 @ a
                          GHC.Types.True -> v `cast` (UnsafeCo representational a1 a) } }),
                     \ (x :: Data.Dynamic.Dynamic) ->
                     Data.Aeson.Types.ToJSON.toJSON
                       @ a
                       w2
                       (case x of wild { Data.Dynamic.Dynamic a1 t v ->
                        case Data.Typeable.Internal.sameTypeRep
                               @ *
                               @ *
                               @ a1
                               @ a
                               t
                               w `cast`
                               (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N) of wild1 {
                          GHC.Types.False -> Data.Maybe.fromJust1 @ a
                          GHC.Types.True -> v `cast` (UnsafeCo representational a1 a) } })),
                    case ds of wild { (,,) ed thereaders thejsoners -> thereaders },
                    case ds of wild { (,,) ed thereaders thejsoners ->
                    thejsoners } #)) -}
1ee8cf5583ce58c49ca42555af1f174b
  $wexp2Dyn ::
    Lola.Expr a
    -> DecDyn.DecMap
    -> (# DecDyn.DecMap, DecDyn.ExprDyn, DecDyn.Readers,
          DecDyn.FromJSONers #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2] -}
9f515e6f7c175ce982a5cad7bfabfc00
  type DecDyn =
    (DecDyn.DeclarationDyn,
     (Data.Dynamic.Dynamic -> GHC.Base.String,
      Data.Dynamic.Dynamic -> Data.Aeson.Types.Internal.Value),
     DecDyn.Readers, DecDyn.FromJSONers)
47f32a3ad3f5edeea0bb9cb12760da9d
  type DecMap =
    Data.Map.Internal.Map
      Lola.Ident
      (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers)
1965aa6f1af02783601d880422aeb48a
  data DeclarationDyn where
    DInp :: Lola.Ident -> DeclarationDyn
    DOut :: (Lola.Ident, DecDyn.ExprDyn) -> DeclarationDyn
1965aa6f1af02783601d880422aeb48a
  data ExprDyn where
    DLeaf :: Data.Dynamic.Dynamic -> ExprDyn
    DApp :: DecDyn.ExprDyn -> DecDyn.ExprDyn -> ExprDyn
    DNow :: DecDyn.DeclarationDyn -> ExprDyn
    DAt :: DecDyn.DeclarationDyn
           -> (GHC.Types.Int, Data.Dynamic.Dynamic) -> ExprDyn
ecae1250810799f9368cb3bd439442ed
  data Format = JSON | CSV
c16b4d0a2a2589296c08a3ff6526e908
  type FromJSONers =
    Data.Map.Internal.Map
      Lola.Ident
      (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic)
d9f641b73b36a9c61e4c1b3caa98d7e3
  type Readers =
    Data.Map.Internal.Map
      Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic)
8ccdcd2b29287a77dbf01dead617648f
  type Specification = [DecDyn.DecDyn]
0c4b5580db617f2eb71be81979564236
  dec2Dyn ::
    (Lola.Streamable a, GHC.Show.Show a,
     Data.Aeson.Types.ToJSON.ToJSON a) =>
    Lola.Declaration a -> DecDyn.DecDyn
  {- Arity: 4,
     Strictness: <L,U><L,U(A,C(U),A)><L,U(C(U),A,A,A)><L,1*U>m,
     Inline: [2],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: Lola.Streamable a)
                   (w1 :: GHC.Show.Show a)
                   (w2 :: Data.Aeson.Types.ToJSON.ToJSON a)
                   (w3 :: Lola.Declaration a) ->
                 case DecDyn.$wdec2Dyn
                        @ a
                        w
                        w1
                        w2
                        w3 of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2, ww3, ww4) }) -}
9e334e120c6e1960467b080c392088a0
  dec2Dyn' :: DecDyn.DecMap -> Lola.Declaration a -> DecDyn.DecMap
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ @ a
                   (themap :: DecDyn.DecMap)
                   (dec :: Lola.Declaration a) ->
                 let {
                   $j :: DecDyn.DecMap <join 0>
                   = case dec of wild {
                       Lola.Input $dFromJSON $dRead $dTypeable id
                       -> DecDyn.$sinsert_$sgo8
                            @ (DecDyn.DeclarationDyn,
                               Data.Map.Internal.Map
                                 Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic),
                               Data.Map.Internal.Map
                                 Lola.Ident
                                 (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic))
                            id
                            (DecDyn.DInp id,
                             case id of dt { DEFAULT ->
                             Data.Map.Internal.Bin
                               @ Lola.Ident
                               @ (GHC.Base.String -> Data.Dynamic.Dynamic)
                               1#
                               dt
                               (\ (x :: GHC.Base.String) ->
                                Data.Dynamic.Dynamic
                                  @ a
                                  $dTypeable
                                    `cast`
                                  (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                                  (Text.Read.read @ a $dRead x))
                               (Data.Map.Internal.Tip
                                  @ Lola.Ident
                                  @ (GHC.Base.String -> Data.Dynamic.Dynamic))
                               (Data.Map.Internal.Tip
                                  @ Lola.Ident
                                  @ (GHC.Base.String -> Data.Dynamic.Dynamic)) },
                             case id of dt { DEFAULT ->
                             Data.Map.Internal.Bin
                               @ Lola.Ident
                               @ (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic)
                               1#
                               dt
                               (\ (x :: Data.Aeson.Types.Internal.Value) ->
                                Data.Dynamic.Dynamic
                                  @ a
                                  $dTypeable
                                    `cast`
                                  (Data.Typeable.Internal.N:Typeable[0] <*>_N <a>_N)
                                  (case (Data.Aeson.Types.FromJSON.parseJSON @ a $dFromJSON x)
                                          `cast`
                                        (Data.Aeson.Types.Internal.N:Parser[0] <a>_R)
                                          @ GHC.Maybe.Maybe
                                          @ a
                                          (GHC.Types.[] @ Data.Aeson.Types.Internal.JSONPathElement)
                                          (DecDyn.dec2Dyn'1 @ a)
                                          (GHC.Maybe.Just @ a) of wild1 {
                                     GHC.Maybe.Nothing -> Data.Maybe.fromJust1 @ a
                                     GHC.Maybe.Just x1 -> x1 }))
                               (Data.Map.Internal.Tip
                                  @ Lola.Ident
                                  @ (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic))
                               (Data.Map.Internal.Tip
                                  @ Lola.Ident
                                  @ (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic)) })
                            themap
                       Lola.Output $dTypeable ds
                       -> case ds of wild1 { (,) id exp ->
                          letrec {
                            ddec :: DecDyn.ExprDyn
                            = case ds1 of wild2 { (,,,) themap2 ddec1 readers jsoners ->
                              ddec1 }
                            outdec :: (Lola.Ident, DecDyn.ExprDyn) {- Strictness: m -}
                            = (id, ddec)
                            outdec1 :: DecDyn.DeclarationDyn = DecDyn.DOut outdec
                            ds1 :: (DecDyn.DecMap, DecDyn.ExprDyn, DecDyn.Readers,
                                    DecDyn.FromJSONers)
                            = case DecDyn.$wexp2Dyn
                                     @ a
                                     exp
                                     (DecDyn.$sinsert_$sgo8
                                        @ (DecDyn.DeclarationDyn,
                                           Data.Map.Internal.Map
                                             Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic),
                                           Data.Map.Internal.Map
                                             Lola.Ident
                                             (Data.Aeson.Types.Internal.Value
                                              -> Data.Dynamic.Dynamic))
                                        id
                                        (outdec1,
                                         Data.Map.Internal.Tip
                                           @ Lola.Ident
                                           @ (GHC.Base.String -> Data.Dynamic.Dynamic),
                                         Data.Map.Internal.Tip
                                           @ Lola.Ident
                                           @ (Data.Aeson.Types.Internal.Value
                                              -> Data.Dynamic.Dynamic))
                                        themap) of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                              (ww1, ww2, ww3, ww4) }
                          } in
                          case ds1 of wild2 { (,,,) themap2 ddec1 readers jsoners ->
                          DecDyn.$sinsert_$sgo8
                            @ (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers)
                            id
                            (outdec1, readers, jsoners)
                            themap2 } } }
                 } in
                 case dec of wild {
                   Lola.Input $dFromJSON $dRead $dTypeable x
                   -> case DecDyn.$smember1
                             @ (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers)
                             x
                             themap of wild1 {
                        GHC.Types.False -> $j GHC.Types.True -> themap }
                   Lola.Output $dTypeable ds1
                   -> case ds1 of wild1 { (,) x ds2 ->
                      case DecDyn.$smember1
                             @ (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers)
                             x
                             themap of wild2 {
                        GHC.Types.False -> $j GHC.Types.True -> themap } } }) -}
e15e557f87c65b062db051b75d6b1267
  dec2Dyn'1 ::
    Data.Aeson.Types.Internal.JSONPath
    -> GHC.Base.String -> GHC.Maybe.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: (\ @ a
                   (ds :: Data.Aeson.Types.Internal.JSONPath)
                   (ds1 :: GHC.Base.String) ->
                 GHC.Maybe.Nothing @ a) -}
75e4e37aa42d35b959226c4f1c2fcfb5
  dgetId :: DecDyn.DeclarationDyn -> Lola.Ident
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: DecDyn.DeclarationDyn) ->
                 case ds of wild {
                   DecDyn.DInp x -> x
                   DecDyn.DOut ds1 -> case ds1 of wild1 { (,) x ds2 -> x } }) -}
fbc8b96fa9fc8fd330152a0e60debf60
  exp2Dyn ::
    Lola.Expr a
    -> DecDyn.DecMap
    -> (DecDyn.DecMap, DecDyn.ExprDyn, DecDyn.Readers,
        DecDyn.FromJSONers)
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Lola.Expr a) (w1 :: DecDyn.DecMap) ->
                 case DecDyn.$wexp2Dyn @ a w w1 of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2, ww3, ww4) }) -}
5560085e9fff1242c6fecdb994f96503
  fst4 :: (a, b, c, d) -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b @ c @ d (ds :: (a, b, c, d)) ->
                 case ds of wild { (,,,) a1 ds1 ds2 ds3 -> a1 }) -}
569682126d23e3ec9c2b4730e18ec525
  fth4 :: (a, b, c, d) -> d
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b @ c @ d (ds :: (a, b, c, d)) ->
                 case ds of wild { (,,,) ds1 ds2 ds3 d1 -> d1 }) -}
17e88acb01c2fa1a932415efa2faeb7f
  getFromJSONers :: DecDyn.Specification -> DecDyn.FromJSONers
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (decs :: DecDyn.Specification) ->
                 letrec {
                   go2 :: [(DecDyn.DeclarationDyn,
                            (Data.Dynamic.Dynamic -> GHC.Base.String,
                             Data.Dynamic.Dynamic -> Data.Aeson.Types.Internal.Value),
                            DecDyn.Readers, DecDyn.FromJSONers)]
                          -> Data.Map.Internal.Map
                               Lola.Ident
                               (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic)
                          -> Data.Map.Internal.Map
                               Lola.Ident
                               (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic)
                     <join 2> {- Arity: 2 -}
                   = \ (ds :: [(DecDyn.DeclarationDyn,
                                (Data.Dynamic.Dynamic -> GHC.Base.String,
                                 Data.Dynamic.Dynamic -> Data.Aeson.Types.Internal.Value),
                                DecDyn.Readers, DecDyn.FromJSONers)])
                       (eta :: Data.Map.Internal.Map
                                 Lola.Ident
                                 (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic)) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go2
                            ys
                            (case y of wild1 { (,,,) ds1 ds2 ds3 d ->
                             (DecDyn.getFromJSONers_go13 eta d)
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <Data.Map.Internal.Map
                                     Lola.Ident
                                     (Data.Aeson.Types.Internal.Value
                                      -> Data.Dynamic.Dynamic)>_R) }) }
                 } in
                 go2
                   decs
                   (Data.Map.Internal.Tip
                      @ Lola.Ident
                      @ (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic))) -}
7ac982f3c0f87df0d59437e65d944690
  getFromJSONers_go13 ::
    Data.Map.Internal.Map
      Lola.Ident
      (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic)
    -> Data.Map.Internal.Map
         Lola.Ident
         (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic)
    -> Data.Functor.Identity.Identity
         (Data.Map.Internal.Map
            Lola.Ident
            (Data.Aeson.Types.Internal.Value -> Data.Dynamic.Dynamic))
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
b0bb01feff0c99569b1a59c5c1dfaf2d
  getReaders :: DecDyn.Specification -> DecDyn.Readers
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (decs :: DecDyn.Specification) ->
                 letrec {
                   go2 :: [(DecDyn.DeclarationDyn,
                            (Data.Dynamic.Dynamic -> GHC.Base.String,
                             Data.Dynamic.Dynamic -> Data.Aeson.Types.Internal.Value),
                            DecDyn.Readers, DecDyn.FromJSONers)]
                          -> Data.Map.Internal.Map
                               Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic)
                          -> Data.Map.Internal.Map
                               Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic)
                     <join 2> {- Arity: 2 -}
                   = \ (ds :: [(DecDyn.DeclarationDyn,
                                (Data.Dynamic.Dynamic -> GHC.Base.String,
                                 Data.Dynamic.Dynamic -> Data.Aeson.Types.Internal.Value),
                                DecDyn.Readers, DecDyn.FromJSONers)])
                       (eta :: Data.Map.Internal.Map
                                 Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic)) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go2
                            ys
                            (case y of wild1 { (,,,) ds1 ds2 c ds3 ->
                             (DecDyn.getReaders_go13 eta c)
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <Data.Map.Internal.Map
                                     Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic)>_R) }) }
                 } in
                 go2
                   decs
                   (Data.Map.Internal.Tip
                      @ Lola.Ident
                      @ (GHC.Base.String -> Data.Dynamic.Dynamic))) -}
addd50b4bb5d4328700ecd7d99eaf453
  getReaders_go13 ::
    Data.Map.Internal.Map
      Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic)
    -> Data.Map.Internal.Map
         Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic)
    -> Data.Functor.Identity.Identity
         (Data.Map.Internal.Map
            Lola.Ident (GHC.Base.String -> Data.Dynamic.Dynamic))
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
fce5654af84855f268138b5525329c31
  out ::
    (Lola.Streamable a, GHC.Show.Show a,
     Data.Aeson.Types.ToJSON.ToJSON a) =>
    Lola.Declaration a -> DecDyn.DecDyn
  {- Arity: 4,
     Strictness: <L,U><L,U(A,C(U),A)><L,U(C(U),A,A,A)><L,1*U>m,
     Unfolding: InlineRule (0, True, True) DecDyn.dec2Dyn -}
fc5b1bf62e0f94eb6f5a03dc9230705e
  snd4 :: (a, b, c, d) -> b
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b @ c @ d (ds :: (a, b, c, d)) ->
                 case ds of wild { (,,,) ds1 b1 ds2 ds3 -> b1 }) -}
ec0bac9e51a401e8b5cbc69384f94abf
  thd4 :: (a, b, c, d) -> c
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b @ c @ d (ds :: (a, b, c, d)) ->
                 case ds of wild { (,,,) ds1 ds2 c1 ds3 -> c1 }) -}
instance GHC.Classes.Eq [DecDyn.Format] = DecDyn.$fEqFormat
instance GHC.Show.Show [DecDyn.DeclarationDyn]
  = DecDyn.$fShowDeclarationDyn
instance GHC.Show.Show [DecDyn.ExprDyn] = DecDyn.$fShowExprDyn
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

