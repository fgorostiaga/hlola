
==================== FINAL INTERFACE ====================
2019-10-21 10:04:24.344848 UTC

interface main:QuickCheck 8065
  interface hash: 72ba882e11e720bf078b56a96319001e
  ABI hash: 3a936fabf75a441cc22a2ebe3fc17be1
  export-list hash: 2ca6faa10ff097a36aa98304ede3ed96
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: cd9faad59dd0db192792099514190d2a
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  QuickCheck.historically_is_correct
  QuickCheck.main
  QuickCheck.myspec
  QuickCheck.p
module dependencies:
package dependencies: HLola-0.1.0.0 MissingH-1.4.1.0
                      QuickCheck-2.13.2 aeson-1.4.5.0 array-0.5.3.0 attoparsec-0.13.2.3
                      base-4.12.0.0 base-compat-0.10.5 base-orphans-0.8.1 binary-0.8.6.0
                      bytestring-0.10.8.2 containers-0.6.0.1 deepseq-1.4.4.0
                      dlist-0.8.0.7 ghc-boot-th-8.6.5 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.3 mtl-2.2.2
                      parsec-3.1.14.0 pretty-1.1.3.6 primitive-0.6.4.0 random-1.1
                      scientific-0.3.6.2 splitmix-0.0.3 tagged-0.8.6
                      template-haskell-2.14.0.0 text-1.2.3.1 time-1.8.0.2
                      time-compat-1.9.2.2 transformers-0.5.6.2
                      unordered-containers-0.2.10.0 uuid-types-1.0.3 vector-0.12.0.3
orphans: HLola-0.1.0.0:Syntax.Num
         attoparsec-0.13.2.3:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.3:Data.Attoparsec.ByteString.Char8
         time-1.8.0.2:Data.Time.Clock.TAI
         vector-0.12.0.3:Data.Vector.Unboxed
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show
         vector-0.12.0.3:Data.Vector.Fusion.Bundle
         transformers-0.5.6.2:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: aeson-1.4.5.0:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.3:Data.Attoparsec.Internal.Types
                         base-4.12.0.0:Control.Applicative base-4.12.0.0:Data.Complex
                         base-4.12.0.0:Data.Functor.Compose base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         dlist-0.8.0.7:Data.DList ghc-boot-th-8.6.5:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.5:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unordered-containers-0.2.10.0:Data.HashMap.Base
                         unordered-containers-0.2.10.0:Data.HashSet.Base
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.3:Data.Vector vector-0.12.0.3:Data.Vector.Primitive
                         vector-0.12.0.3:Data.Vector.Storable
                         vector-0.12.0.3:Data.Vector.Unboxed
                         vector-0.12.0.3:Data.Vector.Unboxed.Base
import  -/  HLola-0.1.0.0:DecDyn e44279c7ab4d42b81c75c5ed2ac16b6e
import  -/  HLola-0.1.0.0:InFromFile c8183c32d03844007e475c81365e76cc
import  -/  HLola-0.1.0.0:Lib.LTL 1aeef460f9869d05f1dc3ad16d7a16dc
import  -/  HLola-0.1.0.0:Lola f52d080a9c6c535055cc2d321870899c
import  -/  QuickCheck-2.13.2:Test.QuickCheck 49a60223418ee7425a09180749cc04b2
import  -/  QuickCheck-2.13.2:Test.QuickCheck.Test 5b154eefeeb68e3fd279058fdca2311f
import  -/  aeson-1.4.5.0:Data.Aeson cd1e38ad278b969589c5b1ad8a30af94
import  -/  base-4.12.0.0:Data.Dynamic ef74395f5e02d1f1b1dbed7092c8bd30
import  -/  base-4.12.0.0:Data.Foldable efb37371da929e7bc88d896298d2d979
import  -/  base-4.12.0.0:Data.List 17d0c71c557e42abe196f130788fd997
import  -/  base-4.12.0.0:Data.Maybe 9b76a39e833465c3c5b3c078b431417f
import  -/  base-4.12.0.0:Data.OldList e931cf456dc87f11ee6e6fb153bca23e
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  bytestring-0.10.8.2:Data.ByteString.Lazy.Char8 ee271bbed336425979c30600663f1b4d
import  -/  containers-0.6.0.1:Data.Map.Internal 9e74e122af4fa0c1b8d4c844eeda9c98
import  -/  containers-0.6.0.1:Data.Map.Strict cdbeca9dfcd61c917272d3c2b8a5e4c8
import  -/  containers-0.6.0.1:Data.Map.Strict.Internal c59f919ec34c302d6b3008d3c43cbfe7
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
df226dc92fd5396278f5fe2eb6d30a95
  $sdec2Dyn1 :: Data.Typeable.Internal.TypeRep GHC.Types.Bool
  {- Unfolding: (case Data.Typeable.Internal.$wmkTrCon
                        @ *
                        @ GHC.Types.Bool
                        14182099612280475667##
                        2734577064602454082##
                        GHC.Types.$trModule
                        GHC.Types.$tcBool1
                        0#
                        GHC.Types.krep$*
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.SomeTypeRep) of ww7 { (#,,,,#) ww8 ww9 ww10 ww11 ww12 ->
                 Data.Typeable.Internal.TrTyCon
                   @ *
                   @ GHC.Types.Bool
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12 }) -}
3184c7d3a506fd8800b987b1ac7435fb
  $sfind1 ::
    [GHC.Types.Char] -> Data.Map.Internal.Map [GHC.Types.Char] a -> a
  {- Arity: 2, Strictness: <S,U><S,1*U> -}
fd5d6fa92a0e634a7e382defbf249105
  $sinsert_$sgo13 ::
    [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> a1
    -> Data.Map.Internal.Map [GHC.Types.Char] a1
    -> Data.Map.Internal.Map [GHC.Types.Char] a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
829cefb560bab9225913f0db16e1c000
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   QuickCheck.$trModule3
                   QuickCheck.$trModule1) -}
c944c81b40a90e8f7e322874e15f6ff2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS QuickCheck.$trModule2) -}
226275e7605b6293488349fc31d1ef4a
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("QuickCheck"#) -}
e77e102a64d068cb17b2c121fef9eecb
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS QuickCheck.$trModule4) -}
0f060c28d2dc8c5c5a8af98da2c705f8
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
6775e0b5b0de8e6349815b8c5622d823
  $w$j ::
    Data.Aeson.Types.Internal.Value
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Data.Aeson.Types.Internal.Value)[OneShot] ->
                 case w of wild {
                   DEFAULT
                   -> Data.Maybe.fromJust1
                        @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                   Data.Aeson.Types.Internal.Object obj
                   -> case (QuickCheck.historically_is_correct_go15 obj)
                             `cast`
                           (Data.Aeson.Types.Internal.N:Parser[0]
                                <Data.HashMap.Base.HashMap
                                   Data.Text.Internal.Text GHC.Types.Bool>_R)
                             @ Data.Aeson.Types.Internal.Result
                             @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                             (GHC.Types.[] @ Data.Aeson.Types.Internal.JSONPathElement)
                             QuickCheck.historically_is_correct10
                             QuickCheck.historically_is_correct9 of wild1 {
                        Data.Aeson.Types.Internal.Error ipv
                        -> Data.Maybe.fromJust1
                             @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                        Data.Aeson.Types.Internal.Success a4 -> a4 } }) -}
183d33934899ea3454ce7651451c0df3
  $wgo1 ::
    Data.HashMap.Array.Array
      (Data.HashMap.Base.HashMap Data.Text.Internal.Text GHC.Types.Bool)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U(U)><S,U><S,U><S,1*U>,
     Inline: [2] -}
9e57ab2c7540d8d8802a309f7d904b9d
  $wgo15 ::
    Data.HashMap.Array.Array
      (Data.HashMap.Base.Leaf Data.Text.Internal.Text GHC.Types.Bool)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U(U)><S,U><S,U><S,1*U>,
     Inline: [2] -}
dfe0a23aa35c2521b284e0a8f65ebe29
  $wgo2 ::
    Data.HashMap.Array.Array
      (Data.HashMap.Base.HashMap Data.Text.Internal.Text GHC.Types.Bool)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U(U)><S,U><S,U><S,1*U>,
     Inline: [2] -}
1131068c93460917e702bf201746d88e
  historically_is_correct :: [GHC.Types.Bool] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (bs :: [GHC.Types.Bool]) ->
                 let {
                   themaps :: [Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool]
                   = GHC.Base.map
                       @ [GHC.Types.Char]
                       @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                       QuickCheck.historically_is_correct8
                       (Data.OldList.lines
                          (InFromFile.runSpecJSON
                             GHC.Types.False
                             QuickCheck.myspec
                             (Data.OldList.unlines
                                (GHC.Base.map
                                   @ GHC.Types.Bool
                                   @ [GHC.Types.Char]
                                   QuickCheck.historically_is_correct7
                                   bs))))
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,U> -}
                   = \ (x :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       l :: [GHC.Types.Bool]
                       = GHC.Base.map
                           @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                           @ GHC.Types.Bool
                           QuickCheck.historically_is_correct4
                           themaps
                     } in
                     case QuickCheck.historically_is_correct_go1
                            (GHC.List.reverse1
                               @ GHC.Types.Bool
                               l
                               (GHC.Types.[] @ GHC.Types.Bool))
                            0# of wild {
                       GHC.Maybe.Nothing
                       -> case x of lwild {
                            DEFAULT -> GHC.Types.False 0# -> GHC.Types.True }
                       GHC.Maybe.Just x1
                       -> case GHC.List.$wlenAcc @ GHC.Types.Bool l 0# of ww2 { DEFAULT ->
                          case x1 of wild1 { GHC.Types.I# y ->
                          GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.==#
                               (GHC.Prim.-# x 1#)
                               (GHC.Prim.-# (GHC.Prim.-# ww2 y) 1#)) } } }
                 } in
                 case QuickCheck.historically_is_correct_go
                        (GHC.Base.map
                           @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                           @ GHC.Types.Bool
                           QuickCheck.historically_is_correct1
                           themaps)
                        0# of wild {
                   GHC.Maybe.Nothing
                   -> case GHC.List.$wlenAcc
                             @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                             themaps
                             0# of ww2 { DEFAULT ->
                      $j ww2 }
                   GHC.Maybe.Just v
                   -> case v of wild1 { GHC.Types.I# x -> $j x } }) -}
4f15c26e6789be98e23b11421c4645fc
  historically_is_correct1 ::
    Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
    -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (m :: Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool) ->
                 QuickCheck.$sfind1
                   @ GHC.Types.Bool
                   QuickCheck.historically_is_correct2
                   m) -}
d183ce71414df45bcce7fb97cabffa3f
  historically_is_correct10 ::
    Data.Aeson.Types.Internal.JSONPath
    -> GHC.Base.String
    -> Data.Aeson.Types.Internal.Result
         (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,U>m1,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Data.Aeson.Types.Internal.JSONPath)
                   (eta :: GHC.Base.String) ->
                 Data.Aeson.Types.Internal.Error
                   @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                   eta) -}
72b78d1bf8b6a8174b2d4578dfdc321a
  historically_is_correct11 ::
    Data.Attoparsec.ByteString.Lazy.Result
      Data.Aeson.Types.Internal.Value
  {- Unfolding: (Data.Attoparsec.ByteString.Lazy.parse_$sgo
                   @ Data.Aeson.Types.Internal.Value
                   (Data.Aeson.Parser.Internal.$wjsonEOF
                      @ Data.Aeson.Types.Internal.Value
                      __NULL
                      Data.ByteString.Internal.$fMonoidByteString1
                      0#
                      0#
                      0#
                      0#
                      0#
                      Data.Attoparsec.Internal.Types.Incomplete
                      (Data.Attoparsec.ByteString.Internal.failK
                         @ Data.Aeson.Types.Internal.Value)
                        `cast`
                      (Sub (Sym (Data.Attoparsec.Internal.Types.D:R:StateByteString[0]))
                       ->_R <Data.Attoparsec.Internal.Types.Pos
                             -> Data.Attoparsec.Internal.Types.More
                             -> [GHC.Base.String]
                             -> GHC.Base.String
                             -> Data.Attoparsec.Internal.Types.IResult
                                  Data.ByteString.Internal.ByteString
                                  Data.Aeson.Types.Internal.Value>_R)
                      (Data.Attoparsec.ByteString.Internal.successK
                         @ Data.Aeson.Types.Internal.Value)
                        `cast`
                      (Sub (Sym (Data.Attoparsec.Internal.Types.D:R:StateByteString[0]))
                       ->_R <Data.Attoparsec.Internal.Types.Pos
                             -> Data.Attoparsec.Internal.Types.More
                             -> Data.Aeson.Types.Internal.Value
                             -> Data.Attoparsec.Internal.Types.IResult
                                  Data.ByteString.Internal.ByteString
                                  Data.Aeson.Types.Internal.Value>_R))) -}
62899485ad9387095058253353550c6b
  historically_is_correct2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   QuickCheck.historically_is_correct3) -}
68a0659b921945c85223d420995554c5
  historically_is_correct3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("p"#) -}
112751bf8fc2406443ffe2b83ca3dd25
  historically_is_correct4 ::
    Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
    -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (m :: Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool) ->
                 QuickCheck.$sfind1
                   @ GHC.Types.Bool
                   QuickCheck.historically_is_correct5
                   m) -}
61aa84b2ffc14ff1d0acfd2f91b906f4
  historically_is_correct5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   QuickCheck.historically_is_correct6) -}
2214cba60452a3214e75013b178543b6
  historically_is_correct6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("historically<p>"#) -}
eace4bf1856d3443e7603fb616c5b75d
  historically_is_correct7 :: GHC.Types.Bool -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (x :: GHC.Types.Bool) ->
                 Data.ByteString.Lazy.Internal.unpackChars
                   (Data.ByteString.Builder.toLazyByteString
                      (case x of x1 { DEFAULT ->
                       case QuickCheck.historically_is_correct_go13
                              Data.Aeson.Encoding.Internal.Empty
                              (Data.Map.Internal.Bin
                                 @ [GHC.Types.Char]
                                 @ GHC.Types.Bool
                                 1#
                                 QuickCheck.historically_is_correct2
                                 x1
                                 (Data.Map.Internal.Tip @ [GHC.Types.Char] @ GHC.Types.Bool)
                                 (Data.Map.Internal.Tip
                                    @ [GHC.Types.Char]
                                    @ GHC.Types.Bool)) of wild1 {
                         Data.Aeson.Encoding.Internal.Empty
                         -> Data.Aeson.Encoding.Builder.emptyObject_1
                              `cast`
                            ((forall (r :: <*>_N).
                              <Data.ByteString.Builder.Internal.BuildStep r>_R
                              ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                              ->_R Sym (GHC.Types.N:IO[0]
                                            <Data.ByteString.Builder.Internal.BuildSignal
                                               r>_R)) ; Sym (Data.ByteString.Builder.Internal.N:Builder[0]))
                         Data.Aeson.Encoding.Internal.Value v1
                         -> (\ @ r (x2 :: Data.ByteString.Builder.Internal.BuildStep r) ->
                             let {
                               w :: Data.ByteString.Builder.Internal.BuildStep r
                               = v1
                                   `cast`
                                 (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                      <Data.Aeson.Encoding.Internal.Series>_P ; Data.ByteString.Builder.Internal.N:Builder[0])
                                   @ r
                                   (Data.Aeson.Encoding.Internal.closeCurly1 @ r x2)
                                     `cast`
                                   (<Data.ByteString.Builder.Internal.BufferRange>_R
                                    ->_R Sym (GHC.Types.N:IO[0]
                                                  <Data.ByteString.Builder.Internal.BuildSignal
                                                     r>_R))
                             } in
                             (\ (w1 :: Data.ByteString.Builder.Internal.BufferRange)
                                (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                              case w1 of ww { Data.ByteString.Builder.Internal.BufferRange ww1 ww2 ->
                              Data.Aeson.Encoding.Internal.$wopenCurly @ r w ww1 ww2 w2 })
                               `cast`
                             (<Data.ByteString.Builder.Internal.BufferRange>_R
                              ->_R Sym (GHC.Types.N:IO[0]
                                            <Data.ByteString.Builder.Internal.BuildSignal r>_R)))
                              `cast`
                            (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) } }))) -}
2d5fff2334b29fecaff7a3a93a0e1a49
  historically_is_correct8 ::
    [GHC.Types.Char]
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [GHC.Types.Char]) ->
                 case Data.ByteString.Lazy.Internal.$wpackChunks1 32# x of wild {
                   Data.ByteString.Lazy.Internal.Empty
                   -> case QuickCheck.historically_is_correct11 of wild1 {
                        Data.Attoparsec.ByteString.Lazy.Fail ipv ipv1 ipv2
                        -> Data.Maybe.fromJust1
                             @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                        Data.Attoparsec.ByteString.Lazy.Done ds v -> QuickCheck.$w$j v }
                   Data.ByteString.Lazy.Internal.Chunk dt dt1 dt2 dt3 xs
                   -> case Data.Attoparsec.ByteString.Lazy.parse_go
                             @ Data.Aeson.Types.Internal.Value
                             (Data.Aeson.Parser.Internal.$wjsonEOF
                                @ Data.Aeson.Types.Internal.Value
                                dt
                                dt1
                                dt2
                                dt3
                                dt3
                                0#
                                0#
                                Data.Attoparsec.Internal.Types.Incomplete
                                (Data.Attoparsec.ByteString.Internal.failK
                                   @ Data.Aeson.Types.Internal.Value)
                                  `cast`
                                (Sub (Sym (Data.Attoparsec.Internal.Types.D:R:StateByteString[0]))
                                 ->_R <Data.Attoparsec.Internal.Types.Pos
                                       -> Data.Attoparsec.Internal.Types.More
                                       -> [GHC.Base.String]
                                       -> GHC.Base.String
                                       -> Data.Attoparsec.Internal.Types.IResult
                                            Data.ByteString.Internal.ByteString
                                            Data.Aeson.Types.Internal.Value>_R)
                                (Data.Attoparsec.ByteString.Internal.successK
                                   @ Data.Aeson.Types.Internal.Value)
                                  `cast`
                                (Sub (Sym (Data.Attoparsec.Internal.Types.D:R:StateByteString[0]))
                                 ->_R <Data.Attoparsec.Internal.Types.Pos
                                       -> Data.Attoparsec.Internal.Types.More
                                       -> Data.Aeson.Types.Internal.Value
                                       -> Data.Attoparsec.Internal.Types.IResult
                                            Data.ByteString.Internal.ByteString
                                            Data.Aeson.Types.Internal.Value>_R))
                             xs of wild1 {
                        Data.Attoparsec.ByteString.Lazy.Fail ipv ipv1 ipv2
                        -> Data.Maybe.fromJust1
                             @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                        Data.Attoparsec.ByteString.Lazy.Done ds v
                        -> QuickCheck.$w$j v } }) -}
862db7affc6f198aaf068e79bff6efd1
  historically_is_correct9 ::
    Data.HashMap.Base.HashMap Data.Text.Internal.Text GHC.Types.Bool
    -> Data.Aeson.Types.Internal.Result
         (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
  {- Arity: 1, Strictness: <L,1*U>m2,
     Unfolding: (\ (a4 :: Data.HashMap.Base.HashMap
                            Data.Text.Internal.Text GHC.Types.Bool) ->
                 Data.Aeson.Types.Internal.Success
                   @ (Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool)
                   (QuickCheck.historically_is_correct_go14
                      (Data.Map.Internal.Tip @ [GHC.Types.Char] @ GHC.Types.Bool)
                      a4)) -}
caa4746385306a136a9f13c7bdea7ed2
  historically_is_correct_go ::
    [GHC.Types.Bool] -> GHC.Prim.Int# -> GHC.Maybe.Maybe GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
c9c25d6462a60fce6ce8d9a6e9a56ad7
  historically_is_correct_go1 ::
    [GHC.Types.Bool] -> GHC.Prim.Int# -> GHC.Maybe.Maybe GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
1c7be00450d9626303558330ecfca008
  historically_is_correct_go13 ::
    Data.Aeson.Encoding.Internal.Series
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
    -> Data.Aeson.Encoding.Internal.Series
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
137802dfe0fe5eeb4504d2256c911760
  historically_is_correct_go14 ::
    Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
    -> Data.HashMap.Base.HashMap Data.Text.Internal.Text GHC.Types.Bool
    -> Data.Map.Internal.Map [GHC.Types.Char] GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (z36 :: Data.Map.Internal.Map
                             [GHC.Types.Char] GHC.Types.Bool)
                   (ds :: Data.HashMap.Base.HashMap
                            Data.Text.Internal.Text GHC.Types.Bool) ->
                 case ds of wild1 {
                   Data.HashMap.Base.Empty -> z36
                   Data.HashMap.Base.BitmapIndexed dt dt1
                   -> QuickCheck.$wgo2
                        (Data.HashMap.Array.Array
                           @ (Data.HashMap.Base.HashMap
                                Data.Text.Internal.Text GHC.Types.Bool)
                           dt1)
                        (GHC.Prim.sizeofSmallArray#
                           @ (Data.HashMap.Base.HashMap
                                Data.Text.Internal.Text GHC.Types.Bool)
                           dt1)
                        0#
                        z36
                   Data.HashMap.Base.Leaf dt dt1 dt2
                   -> case dt1 of wild { Data.Text.Internal.Text dt4 dt5 dt6 ->
                      let {
                        end :: GHC.Prim.Int# = GHC.Prim.+# dt5 dt6
                      } in
                      letrec {
                        $wunfold :: GHC.Prim.Int# -> [GHC.Types.Char]
                          {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                        = \ (ww :: GHC.Prim.Int#) ->
                          case GHC.Prim.>=# ww end of lwild {
                            DEFAULT
                            -> case GHC.Prim.indexWord16Array# dt4 ww of r# { DEFAULT ->
                               case GHC.Prim.geWord# r# 55296## of lwild1 {
                                 DEFAULT
                                 -> GHC.Types.:
                                      @ GHC.Types.Char
                                      (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                      ($wunfold (GHC.Prim.+# ww 1#))
                                 1#
                                 -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                      DEFAULT
                                      -> GHC.Types.:
                                           @ GHC.Types.Char
                                           (GHC.Types.C# (GHC.Prim.chr# (GHC.Prim.word2Int# r#)))
                                           ($wunfold (GHC.Prim.+# ww 1#))
                                      1#
                                      -> case GHC.Prim.indexWord16Array#
                                                dt4
                                                (GHC.Prim.+# ww 1#) of r#1 { DEFAULT ->
                                         GHC.Types.:
                                           @ GHC.Types.Char
                                           (GHC.Types.C#
                                              (GHC.Prim.chr#
                                                 (GHC.Prim.+#
                                                    9216#
                                                    (GHC.Prim.+#
                                                       (GHC.Prim.uncheckedIShiftL#
                                                          (GHC.Prim.-#
                                                             (GHC.Prim.word2Int# r#)
                                                             55296#)
                                                          10#)
                                                       (GHC.Prim.word2Int# r#1)))))
                                           ($wunfold (GHC.Prim.+# ww 2#)) } } } }
                            1# -> GHC.Types.[] @ GHC.Types.Char }
                      } in
                      let {
                        kx0 :: [GHC.Types.Char] = $wunfold dt5
                      } in
                      QuickCheck.$sinsert_$sgo13 @ GHC.Types.Bool kx0 kx0 dt2 z36 }
                   Data.HashMap.Base.Full dt
                   -> QuickCheck.$wgo1
                        (Data.HashMap.Array.Array
                           @ (Data.HashMap.Base.HashMap
                                Data.Text.Internal.Text GHC.Types.Bool)
                           dt)
                        (GHC.Prim.sizeofSmallArray#
                           @ (Data.HashMap.Base.HashMap
                                Data.Text.Internal.Text GHC.Types.Bool)
                           dt)
                        0#
                        z36
                   Data.HashMap.Base.Collision dt dt1
                   -> QuickCheck.$wgo15
                        (Data.HashMap.Array.Array
                           @ (Data.HashMap.Base.Leaf Data.Text.Internal.Text GHC.Types.Bool)
                           dt1)
                        (GHC.Prim.sizeofSmallArray#
                           @ (Data.HashMap.Base.Leaf Data.Text.Internal.Text GHC.Types.Bool)
                           dt1)
                        0#
                        z36 }) -}
57451e762020ccfd11fa75812c4086d8
  historically_is_correct_go15 ::
    Data.HashMap.Base.HashMap
      Data.Text.Internal.Text Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser
         (Data.HashMap.Base.HashMap Data.Text.Internal.Text GHC.Types.Bool)
  {- Arity: 1, Strictness: <S,1*U> -}
a8f21adc85613340fb93713da89b1e8f
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                QuickCheck.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
fad3cd29484b0fc565daab787dffa3be
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case Test.QuickCheck.Test.$wwithState
                        @ Test.QuickCheck.Test.Result
                        (GHC.Maybe.Nothing @ (Test.QuickCheck.Random.QCGen, GHC.Types.Int))
                        Test.QuickCheck.Test.stdArgs2
                        Test.QuickCheck.Test.stdArgs1
                        Test.QuickCheck.Test.stdArgs2
                        GHC.Types.True
                        GHC.Base.maxInt
                        QuickCheck.main2
                          `cast`
                        (<Test.QuickCheck.State.State>_R
                         ->_R Sym (GHC.Types.N:IO[0] <Test.QuickCheck.Test.Result>_R))
                        w3 of ds3 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
c95187079caf8b229456556299a76504
  main2 ::
    Test.QuickCheck.State.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Test.QuickCheck.Test.Result #)
  {- Arity: 2,
     Strictness: <S(S(LS(S)LC(C(S(SL))))S(S)LLLLSLLSSSSSSLLL),1*U(U(U(U),U(U),U,U),U(U),U(U),U,U,U,U,U,U,U,U,U,U,U,U(U,U),U,U,U)><S,U>,
     Unfolding: (\ (s :: Test.QuickCheck.State.State)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 Test.QuickCheck.Test.quickCheck3
                   s
                   QuickCheck.main3
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0]))
                   eta) -}
372ab9f68db85822b83d29d3961feafb
  main3 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 2,
     Unfolding: (Test.QuickCheck.Property.$fTestableBool1
                   @ [GHC.Types.Bool]
                   QuickCheck.main6
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Bool]>_R))
                   QuickCheck.main5
                   QuickCheck.main4
                   QuickCheck.historically_is_correct) -}
79ea244f43cf7b357cadd9bbdc476db3
  main4 :: [GHC.Types.Bool] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <L,1*U>m2,
     Unfolding: (\ (x :: [GHC.Types.Bool]) ->
                 GHC.Types.:
                   @ GHC.Base.String
                   (GHC.Show.showList__
                      @ GHC.Types.Bool
                      GHC.Show.$fShowBool1
                      x
                      (GHC.Types.[] @ GHC.Types.Char))
                   (GHC.Types.[] @ GHC.Base.String)) -}
b7dd42c2cdb5632e844d4b69eed531d6
  main5 :: [GHC.Types.Bool] -> [[GHC.Types.Bool]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (eta :: [GHC.Types.Bool]) ->
                 Test.QuickCheck.Arbitrary.shrinkList
                   @ GHC.Types.Bool
                   Test.QuickCheck.Arbitrary.$fArbitraryBool_$cshrink
                   eta) -}
64c85aab38f6935f98f65462deaee41c
  main6 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> [GHC.Types.Bool]
  {- Arity: 2, Strictness: <S(SS),1*U(U,U)><S(S),1*U(U)>,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int)[OneShot] ->
                 case eta
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.SplitMix.SMGen ww1 ww2 ->
                 case eta1 of ww3 { GHC.Types.I# ww4 ->
                 Test.QuickCheck.Gen.$wlistOf
                   @ GHC.Types.Bool
                   Test.QuickCheck.Arbitrary.$fArbitraryAll1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Bool>_R))
                   ww1
                   ww2
                   ww4 } }) -}
edb58dbbe968fd5159542da0ad440736
  myspec :: DecDyn.Specification
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ DecDyn.DecDyn
                   QuickCheck.myspec9
                   QuickCheck.myspec1) -}
c2c7b477cdf1f2ce5b0dbcf86308c6f2
  myspec1 :: [DecDyn.DecDyn]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ DecDyn.DecDyn
                   QuickCheck.myspec2
                   (GHC.Types.[] @ DecDyn.DecDyn)) -}
9d91d5b22ceee617b50357c5d46df396
  myspec10 :: Lola.Stream GHC.Types.Bool
  {- Unfolding: (Lib.LTL.historically QuickCheck.p) -}
83baa5bd0942cfec482e505a6d63b7e1
  myspec2 ::
    (DecDyn.DeclarationDyn,
     (Data.Dynamic.Dynamic -> GHC.Base.String,
      Data.Dynamic.Dynamic -> Data.Aeson.Types.Internal.Value),
     DecDyn.Readers, DecDyn.FromJSONers)
  {- Strictness: m,
     Unfolding: ((QuickCheck.myspec8, QuickCheck.myspec5,
                  QuickCheck.myspec4, QuickCheck.myspec3)) -}
b87473aab9e835c26474edbe8aa67a24
  myspec3 :: DecDyn.FromJSONers
  {- Unfolding: (case QuickCheck.myspec_ds of wild { (,,) ed thereaders thejsoners ->
                 thejsoners }) -}
af2b627e8918dc1b402a08dffbb726df
  myspec4 :: DecDyn.Readers
  {- Unfolding: (case QuickCheck.myspec_ds of wild { (,,) ed thereaders thejsoners ->
                 thereaders }) -}
f7cca90754048030b7c04b1e96b47031
  myspec5 ::
    (Data.Dynamic.Dynamic -> GHC.Base.String,
     Data.Dynamic.Dynamic -> Data.Aeson.Types.Internal.Value)
  {- Strictness: m,
     Unfolding: ((QuickCheck.myspec7, QuickCheck.myspec6)) -}
54c72486d6be197a988981d1fda2e0e7
  myspec6 :: Data.Dynamic.Dynamic -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m5,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Dynamic.Dynamic) ->
                 case x of wild { Data.Dynamic.Dynamic a4 t v ->
                 case Data.Typeable.Internal.sameTypeRep
                        @ *
                        @ *
                        @ a4
                        @ GHC.Types.Bool
                        t
                        QuickCheck.$sdec2Dyn1 of wild1 {
                   GHC.Types.False
                   -> case Data.Maybe.fromJust1
                      ret_ty Data.Aeson.Types.Internal.Value
                      of {}
                   GHC.Types.True
                   -> case v `cast`
                           (UnsafeCo representational a4 GHC.Types.Bool) of dt { DEFAULT ->
                      Data.Aeson.Types.Internal.Bool dt } } }) -}
bfef3adba867ad36390dbe2fd995a4de
  myspec7 :: Data.Dynamic.Dynamic -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Dynamic.Dynamic) ->
                 case x of wild { Data.Dynamic.Dynamic a4 t v ->
                 case Data.Typeable.Internal.sameTypeRep
                        @ *
                        @ *
                        @ a4
                        @ GHC.Types.Bool
                        t
                        QuickCheck.$sdec2Dyn1 of wild1 {
                   GHC.Types.False
                   -> case Data.Maybe.fromJust1 ret_ty GHC.Base.String of {}
                   GHC.Types.True
                   -> case v `cast`
                           (UnsafeCo representational a4 GHC.Types.Bool) of wild2 {
                        GHC.Types.False -> GHC.Show.$fShowBool4
                        GHC.Types.True -> GHC.Show.$fShowBool2 } } }) -}
c37be45e0f65f9549654f93a24f0c908
  myspec8 :: DecDyn.DeclarationDyn
  {- Unfolding: (case QuickCheck.myspec_ds of wild { (,,) ed thereaders thejsoners ->
                 ed }) -}
988910d556c7251524eb2f4ed413a02b
  myspec9 :: DecDyn.DecDyn
  {- Unfolding: (case DecDyn.$wdec2Dyn
                        @ GHC.Types.Bool
                        QuickCheck.$sdec2Dyn1
                          `cast`
                        (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <GHC.Types.Bool>_N)
                        GHC.Show.$fShowBool
                        Data.Aeson.Types.ToJSON.$fToJSONBool
                        QuickCheck.myspec10 of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2, ww3, ww4) }) -}
f3ec347baf6a0bd53f85463387ae57d7
  myspec_ds ::
    (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers)
  {- Unfolding: (DecDyn.$sfind1
                   @ (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers)
                   QuickCheck.historically_is_correct2
                   (DecDyn.dec2Dyn'
                      @ GHC.Types.Bool
                      (Data.Map.Internal.Tip
                         @ Lola.Ident
                         @ (DecDyn.DeclarationDyn, DecDyn.Readers, DecDyn.FromJSONers))
                      QuickCheck.p)) -}
5674b5e96ac7e4f5468b55e8dafed03a
  p :: Lola.Stream GHC.Types.Bool
  {- Strictness: m1,
     Unfolding: (Lola.Input
                   @ GHC.Types.Bool
                   Data.Aeson.Types.FromJSON.$fFromJSONBool
                   GHC.Read.$fReadBool
                   QuickCheck.$sdec2Dyn1
                     `cast`
                   (Sym (Data.Typeable.Internal.N:Typeable[0]) <*>_N <GHC.Types.Bool>_N)
                   QuickCheck.historically_is_correct2) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

